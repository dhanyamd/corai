from maya.chains import get_chain, get_code_response, get_instructions
from maya.state import CoraiAgentState
from langchain_core.runnables import RunnableConfig
from langchain_core.messages import AIMessage, HumanMessage, RemoveMessage
import re
from e2b_code_interpreter import Sandbox
from openevals.code.e2b.pyright import create_async_e2b_pyright_evaluator
from langsmith import traceable
from maya.settings import Settings

@traceable
async def input_node(state: CoraiAgentState, config: RunnableConfig ): 
    """
    Contains a prompt and code from the user as input, then generates the detailed
    summary for the prompt and returns the detailed summary and code back.

    Args: 
        messages: str | list[str] | list[dict[str, any]]
    Yields: 
        summary: str 
        code : str | list[str]
    """
    initial_prompt = state.get("messages", "")
    print(f"Input Node received: {initial_prompt}")
    chain = get_chain()
    response = await chain.ainvoke({"initial_prompt": initial_prompt, "messages": initial_prompt}, config)
    # Extract the summary from the response
    if hasattr(response, 'content'):
        summary = response.content
    else:
        summary = str(response)
    return {"summary": summary}
    
@traceable
async def response_node(state: CoraiAgentState, config: RunnableConfig):
    """
    Takes the summary generated and code back by the input_node back and generates code
    for the requested query. The response would be the code block generated by the LLM.
    
    Args:
      summary (str) : The summary generated by the input_node
    Returns:
      code (str): The response or the code generated through the summary and the code provided.
      It returns a code block containing all the changes as guided by the summary prompt.
    """
    summary = state.get("summary", "")
    sandbox_err = state.get("sandbox_response_err", "")
    print(f"summary: ", {summary})
    # Extract the actual summary content if it's a dictionary or other object
    if isinstance(summary, dict):
        # If it's a dictionary, extract the content
        summary_content = str(summary)
    elif hasattr(summary, 'content'):
        # If it's an object with a content attribute, use that
        summary_content = summary.content
    else:
        # Otherwise, convert to string
        summary_content = str(summary)
    
    # Include sandbox error in the summary if it exists
    if sandbox_err:
        # Extract the error content if it's a dictionary
        if isinstance(sandbox_err, dict) and "error" in sandbox_err:
            error_content = "\n".join(sandbox_err["error"])
        else:
            error_content = str(sandbox_err)
        
        # Add the error information to the summary
        summary_content = f"{summary_content}\n\nThe previous attempt failed with the following error:\n{error_content}\n\nPlease fix the code and try again."
    
    # Always generate the code, but do not prepend instructions
    escaped_summary = summary_content.replace("{", "{{").replace("}", "}}") if summary_content else ""
    code_chain = get_code_response(summary=escaped_summary)
    code_gen = await code_chain.ainvoke({"summary": escaped_summary, "messages": state["messages"]}, config)
    
    # Extract content from the code generation
    code = code_gen.content if hasattr(code_gen, 'content') else str(code_gen)
    
    # Add the summary content as a new message to the messages list
    messages = state["messages"] + [HumanMessage(content=summary_content)]
    return {"code": AIMessage(content=code), "messages": messages}

@traceable
def sandbox_node(state: CoraiAgentState):
    """
    A dynamic, multi-language sandbox execution engine.
    """
    code = state.get("code")

    if not code:
        return {"sandbox_response": ["No code found in the state to run."]}

    settings = Settings()
    with Sandbox(api_key=settings.E2B_API_KEY) as sandbox:
        code_content = code.content if hasattr(code, 'content') else str(code)
        
        # Universal code extraction from markdown.
        code_match = re.search(r"```(?:\w+\n)?(.*)```", code_content, re.DOTALL)
        if code_match:
            actual_code_to_run = code_match.group(1).strip()
        else:
            actual_code_to_run = code_content.strip()

        # Failsafe: programmatically remove function redefinitions.
        if "def calculate_discount" in actual_code_to_run:
            actual_code_to_run = re.sub(r"def calculate_discount.*?:(?:\n\s+.*)+", "", actual_code_to_run, flags=re.DOTALL)

        # Language and framework detection.
        language, test_runner, filename, module_name = "python", "unittest", "test_script.py", "module_to_test.py"
        if "react" in actual_code_to_run.lower():
            language, test_runner, filename = "javascript", "jest", "test.js"
        elif "cargo" in actual_code_to_run.lower():
            language, test_runner, filename = "rust", "cargo", "lib.rs"
        elif "java" in actual_code_to_run.lower():
            language, test_runner, filename = "java", "junit", "Test.java"

        # Get the original code snippet from the messages.
        original_code_snippet = ""
        if len(state["messages"]) > 1 and hasattr(state["messages"][1], 'content'):
            original_code_snippet = state["messages"][1].content

        # Base64 encoding for safe file writing.
        import base64
        encoded_test_code = base64.b64encode(actual_code_to_run.encode('utf-8')).decode('utf-8')
        write_test_code_cmd = f"echo '{encoded_test_code}' | base64 -d > {filename}"

        full_script = ""
        if original_code_snippet:
            encoded_original_code = base64.b64encode(original_code_snippet.encode('utf-8')).decode('utf-8')
            write_original_code_cmd = f"echo '{encoded_original_code}' | base64 -d > {module_name}"
            full_script += f"{write_original_code_cmd} && "
        
        full_script += write_test_code_cmd

        # Framework-specific execution commands.
        if test_runner == 'unittest':
            full_script += f" && python -m unittest {filename}"
        elif test_runner == 'pytest':
            full_script += f" && pip install pytest && python -m pytest"
        elif test_runner == 'jest':
            full_script += f" && npm install && npm test"
        elif test_runner == 'cargo':
            full_script += f" && cargo test"
        elif test_runner == 'junit':
            full_script += f" && mvn test"

        print(f"Debug - Language: {language}, Runner: {test_runner}")
        print(f"Debug - Script: {full_script}")

        try:
            proc = sandbox.commands.run(cmd=full_script, timeout=60000)
            output = proc.stdout.split('\n')
            if proc.stderr:
                output.extend(["--- STDERR ---", *proc.stderr.split('\n')])

            if proc.exit_code == 0:
                state["sandbox_response"] = {"output": output, "code": actual_code_to_run}
                if "sandbox_response_err" in state:
                    del state["sandbox_response_err"]
            else:
                state["sandbox_response_err"] = {"error": output, "code": actual_code_to_run}

        except Exception as e:
            state["sandbox_response_err"] = {"error": [f"Exception: {str(e)}"], "code": actual_code_to_run}
        
        return state

@traceable
def final_response(state: CoraiAgentState):
    """
    Formats the final response to be clear and concise.
    """
    sandbox_response = state.get("sandbox_response", {})
    
    # Default to a simple message if the sandbox response is not in the expected format.
    if not isinstance(sandbox_response, dict):
        final_response = {"output": ["Sandbox response not in expected format."], "code": ""}
    else:
        final_response = {
            "output": sandbox_response.get("output", ["No output from sandbox."]),
            "code": sandbox_response.get("code", "# No code executed.")
        }
            
    state["final_response"] = final_response
    return {"final_response": final_response, "messages": state["messages"]}
