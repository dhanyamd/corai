
from maya.chains import get_chain, get_code_response, get_instructions
from maya.state import CoraiAgentState
from langchain_core.runnables import RunnableConfig
from langchain_core.messages import AIMessage, HumanMessage, RemoveMessage
from e2b_code_interpreter import Sandbox
from openevals.code.e2b.pyright import create_async_e2b_pyright_evaluator

async def input_node(state: CoraiAgentState, config: RunnableConfig ): 
    """
    Contains a prompt and code from the user as input, then generates the detailed
    summary for the prompt and returns the detailed summary and code back.

    Args: 
        messages: str | list[str] | list[dict[str, any]]
    Yields: 
        summary: str 
        code : str | list[str]
    """
    initial_prompt = state.get("messages", "")
    print(f"Input Node received: {initial_prompt}")
    chain = get_chain(initial_prompt)
    response = await chain.ainvoke({"messages": initial_prompt}, config)
    return {"summary": AIMessage(content=response) }
    
async def response_node(state: CoraiAgentState, config: RunnableConfig):
    """
    Takes the summary generated and code back by the input_node back and generates code 
    for the requested query. The response would be the code block generated by the LLM.

    Args: 
      summary (str) : The summary generated by the input_node
    Returns: 
      code (str): The response or the code generated through the summary and the code provided. 
      It returns a code block containing all the changes as guided by the summary prompt.
    """
    summary = state.get("summary")
    print(f"summary: ", {summary})
    chain =  get_code_response(summary=summary)
    code_gen = await chain.ainvoke({"summary": summary, "messsages": state["messages"]}, config)
    instructions_chain = get_instructions(code_gen=code_gen)
    instructions = await instructions_chain.ainvoke({"code": code_gen })
    code = instructions + code_gen
    messages = state["messages"] + HumanMessage(content=summary)
    return {"code": AIMessage(content=code), "messages": messages} 


def sandbox_node(state: CoraiAgentState, sandbox: Sandbox): 
    """
    Responsible for running the code in a sandbox background and returning the local result.

    Args: 
     code (str): The code generated by the response_node 
    Returns: 
     locals (dict | list[dict[str, any]]): The metadata response given by the sandbox agent after running the code.
    """
    combined_code_and_instructions = state.get("code")

    if not combined_code_and_instructions:
        # Handle the case where no code is provided
        state["sandbox_response"] = ["No code found in the state to run."]
        return state

    # Separate the instructions and the actual code
    setup_commands = []
    actual_code_lines = []

    for line in combined_code_and_instructions.split('\n'):
        line_stripped = line.strip()
        # Check for commented commands (e.g., // npm install jest or # pip install)
        if line_stripped.startswith('//') or line_stripped.startswith('#'):
            # Extract the command, removing the comment markers and surrounding spaces
            command = line_stripped.lstrip('//').lstrip('#').strip()
            if command:
                setup_commands.append(command)
        else:
            # All other lines are considered actual code
            actual_code_lines.append(line)

    # Re-join the actual code lines into a single string
    actual_code_to_run = '\n'.join(actual_code_lines)

    # Determine a suitable filename based on the first command if possible
    # This is a simple heuristic; a more robust solution might require a more complex parser
    filename = 'script'
    if setup_commands:
        first_command_parts = setup_commands[0].split()
        if len(first_command_parts) > 1 and first_command_parts[1] == 'jest':
            filename = 'index.test.js'
        elif first_command_parts[0] == 'npx' and len(first_command_parts) > 1 and first_command_parts[1] == 'jest':
            filename = 'index.test.js'
        elif first_command_parts[0] == 'pytest':
            filename = 'test_script.py'
        elif 'pip' in first_command_parts:
            filename = 'main.py'
        elif 'npm' in first_command_parts:
            filename = 'index.js'
    
    # Write the user's actual code to a file in the sandbox
    sandbox.filesystem.write(filename, actual_code_to_run)

    # Combine all setup and execution commands into a single command string
    # We use '&&' to ensure that the next command only runs if the previous one was successful
    # This includes writing the file and then running the tests.
    full_script = f"echo '{actual_code_to_run}' > {filename}\n"
    if setup_commands:
        full_script += ' && '.join(setup_commands)
    
    # Run the combined script using the generic `run_command`
    proc = sandbox.commands.run(cmd=full_script)

    # Set the sandbox_response in the state dictionary
    if proc.stdout:
        state["sandbox_response"] = proc.stdout.split('\n')
        state["code"] = actual_code_to_run
    else:
        state["sandbox_response"] = proc.stderr.split('\n')
        return {"sandbox_response", "response_node"}

def final_response(state: CoraiAgentState): 
    """
    Returns the final code output to the user that is ran through the sandbox 

    Args: 
    sandbox_reponse (dict): the response for test cases generated by the sandbox
    final_correct_code (str | list[str]): the final correct code that ran through succesfully in the sandbox 

    Returns: 
    final_response (str | list[str]) : the final code returned and stored in state by combining the two arguments.
    """
    sandbox_response = state.get("sandbox_response", "")
    final_correct_code = state.get("code", "")
    final_response = sandbox_response + final_correct_code 
    state["final_response"] = final_response
    return {"final_response": final_response, "messages": state["messages"]}


